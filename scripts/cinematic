#!/usr/bin/env python

import argparse
import pycinema
import pycinema.filters
import sys

# pycinema settings
PYCINEMA = { 'VERSION' : '3.1.0'}

def is_channel(images, channel):
    if images and channel:
        return channel in images[0].channels
    else:
        return False

def function_meta(args):
    if args.debug:
        # enable debug output (e.g., timings)
        pycinema.Filter._debug = True

    # read scalar image cdb manifest
    CinemaDatabaseReader_0 = pycinema.filters.CinemaDatabaseReader()
    CinemaDatabaseReader_0.inputs.path.set(args.source, False)
    CinemaDatabaseReader_0.inputs.file_column.set(args.filecolumn, False)

    # read actual images
    ImageReader_0 = pycinema.filters.ImageReader()
    ImageReader_0.inputs.table.set(CinemaDatabaseReader_0.outputs.table, False)
    ImageReader_0.inputs.file_column.set(args.filecolumn, False)
    ImageReader_0.inputs.cache.set(True, False)

    # execute pipeline
    CinemaDatabaseReader_0.update()

    # do the work
    images = ImageReader_0.outputs.images.get()
    meta = images[0].meta
    resolution = [int(meta['resolution'][0]), int(meta['resolution'][1])]
    print("image metadata")
    print("  format: hdf5")
    print("  res   : " + ", ".join(map(str, resolution)))
    print("channels: ")
    print("  number: " + str(len(images[0].channels)))
    names = []
    for channel in images[0].channels:
        names.append(channel)
    
    print("  names : " + ", ".join(names))

def function_recolor(args):
    if args.debug:
        # enable debug output (e.g., timings)
        pycinema.Filter._debug = True

    if args.verbose:
        print(args)
        #print("converting: \'" + args.source   + "\' to \'" + args.output + "\'")
        #print("colormap  : \'" + args.colormap + "\'")
        #print("channel   : \'" + args.channel  + "\'")
        #print()

    # read scalar image cdb manifest
    CinemaDatabaseReader_0 = pycinema.filters.CinemaDatabaseReader()
    CinemaDatabaseReader_0.inputs.path.set(args.source, False)
    CinemaDatabaseReader_0.inputs.file_column.set(args.filecolumn, False)

    # read actual images
    ImageReader_0 = pycinema.filters.ImageReader()
    ImageReader_0.inputs.table.set(CinemaDatabaseReader_0.outputs.table, False)
    ImageReader_0.inputs.file_column.set(args.filecolumn, False)
    ImageReader_0.inputs.cache.set(True, False)

    ImageReader_0.update()
    images = ImageReader_0.outputs.images.get()
    if not is_channel(images, args.channel):
        print("ERROR: invalid channel \'" + args.channel + "\'")
        return

    if not is_channel(images, args.depthchannel):
        print("ERROR: invalid channel \'" + args.depthchannel + "\'")
        return

    # depth compositing
    DepthCompositing_0 = pycinema.filters.DepthCompositing()
    DepthCompositing_0.inputs.images_a.set(ImageReader_0.outputs.images, False)
    DepthCompositing_0.inputs.images_b.set([], False)
    DepthCompositing_0.inputs.depth_channel.set(args.depthchannel, False)
    DepthCompositing_0.inputs.compose.set((None, {}), False)

    # Apply color mapping on some channel (here depth)
    # name of the matplotlib color map: https://matplotlib.org/stable/users/explain/colors/colormaps.html
    ColorMapping_0 = pycinema.filters.ColorMapping()
    ColorMapping_0.inputs.map.set(args.colormap, False)
    ColorMapping_0.inputs.nan.set(args.nancolor, False)
    ColorMapping_0.inputs.range.set(args.channelrange, False) # data range of the scalar values
    ColorMapping_0.inputs.channel.set(args.channel, False) # name of the channel that needs to be rendered
    ColorMapping_0.inputs.images.set(DepthCompositing_0.outputs.images, False)
    ColorMapping_0.inputs.composition_id.set(-1, False)

    # write the resulting images to a new cdb
    CinemaDatabaseWriter_0 = pycinema.filters.CinemaDatabaseWriter()
    CinemaDatabaseWriter_0.inputs.images.set(ColorMapping_0.outputs.images, False)
    CinemaDatabaseWriter_0.inputs.path.set(args.output, False)
    CinemaDatabaseWriter_0.inputs.ignore.set(['^id', '^camera', '^FILE'], False)
    CinemaDatabaseWriter_0.inputs.hdf5.set(False, False)

    # execute pipeline
    CinemaDatabaseReader_0.update()

# set up parsers
parser = argparse.ArgumentParser(description="Cinema utility command line tool")
subparsers = parser.add_subparsers(dest='command', help='Sub-commands')

# Subparser for command 'recolor'
parser_recolor = subparsers.add_parser('recolor', help='convert Cinema float (hdf5) images to .png')
parser_recolor.add_argument('--channel', required=True, help='define channel in source images to be colormapped')
parser_recolor.add_argument('--channelrange', nargs="*", type=float, default=[-1.0,1.0], help='define channel range')
parser_recolor.add_argument('--debug', action='store_true', help='set debug mode')
parser_recolor.add_argument('--colormap', default="coolwarm", help='colormap name, from matplotlib color list')
parser_recolor.add_argument('--depthchannel', default="Depth", help='define DEPTH channel name') 
parser_recolor.add_argument('--filecolumn', default="FILE", help='define FILE column name')
parser_recolor.add_argument('--nancolor', nargs="*", type=int, default=[0, 0, 0, 0]) 
parser_recolor.add_argument('--output', default="recolored.cdb", help='output cinema database')
parser_recolor.add_argument('--source', required=True, help='source cinema database')
parser_recolor.add_argument('--thumbnail', action='store_true', help='write out a thumbnail of converted image')
parser_recolor.add_argument('-v', '--verbose', action='store_true', help='enable verbose output')
parser_recolor.set_defaults(func=function_recolor)

# Subparser for command 'meta'
parser_meta = subparsers.add_parser('meta', help='dump descriptive metadata about a cinema database')
parser_meta.add_argument('--debug', action='store_true', help='set debug mode')
parser_meta.add_argument('--filecolumn', default="FILE", help='define FILE column name')
parser_meta.add_argument('-v', '--verbose', action='store_true', help='enable verbose output')
parser_meta.add_argument('source', help='source cinema database')
parser_meta.set_defaults(func=function_meta)

# parse and call subcommand arguments
args = parser.parse_args()

# Call the appropriate function based on the subcommand
if args.command:
    args.func(args)
else:
    parser.print_help()
