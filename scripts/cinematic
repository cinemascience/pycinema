#!/usr/bin/env python

import argparse
import pycinema
import pycinema.filters
import sys

# pycinema settings
PYCINEMA = { 'VERSION' : '3.1.0'}

def is_channel(images, channel):
    if images and channel:
        return channel in images[0].channels
    else:
        return False

#
#
#
class Composite:

    def __init__(self, args):
        self.reader = pycinema.filters.CinemaDatabaseReader()
        self.reader.inputs.path.set(args.source, False)
        self.reader.inputs.file_column.set(args.filecolumn, False)
        # self.reader.update()

        self.elements = []
        for element in args.elements:
            self.elements.append(Element(self, element, args))

        # write the resulting images to a new cdb
        self.writer = pycinema.filters.CinemaDatabaseWriter()
        self.writer.inputs.images.set(self.elements[0].output.images, False)
        self.writer.inputs.path.set(args.output, False)
        self.writer.inputs.ignore.set(['^id', '^camera', '^FILE'], False)
        self.writer.inputs.hdf5.set(False, False)

    def update(self):
        self.reader.update()
#
# create a pipeline that filters, reads and recolors a subset of images
#
class Element:

    def __init__(self, composite, element, args):
        # query
        self.query  = pycinema.filters.TableQuery()
        self.query.inputs.table.set(composite.reader.outputs.table, False)
            # find the elements in the table with a query
        self.query.inputs.sql.set("SELECT * from input WHERE " + args.elementlabel + " = \'" + element + "\'", False)

        # image reader
        self.imReader = pycinema.filters.ImageReader()
        self.imReader.inputs.table.set(self.query.outputs.table, False)
        self.imReader.inputs.file_column.set(args.filecolumn, False)
        self.imReader.inputs.cache.set(True, False)

        composite.reader.update()
        images = self.imReader.outputs.images.get()
        if not is_channel(images, args.channel):
            print("ERROR: invalid channel \'" + args.channel + "\'")
            return

        if not is_channel(images, args.depthchannel):
            print("ERROR: invalid channel \'" + args.depthchannel + "\'")
            return

        # colormap
        self.colormap = pycinema.filters.ColorMapping()
        self.colormap.inputs.map.set(args.colormap, False)
        self.colormap.inputs.nan.set(args.nancolor, False)
        self.colormap.inputs.range.set(args.channelrange, False) # data range of the scalar values
        self.colormap.inputs.channel.set(args.channel, False) # name of the channel that needs to be rendered
        self.colormap.inputs.images.set(self.imReader.outputs.images, False)
        self.colormap.inputs.composition_id.set(-1, False)

        self.output = self.colormap.outputs



def function_recolor(args):
    if args.debug:
        # enable debug output (e.g., timings)
        pycinema.Filter._debug = True
        print(args)

    # if args.verbose:
        # print(args)

    # read scalar image cdb manifest
    composite = Composite(args)
    composite.update()

def function_meta(args):
    if args.debug:
        # enable debug output (e.g., timings)
        pycinema.Filter._debug = True

    # read scalar image cdb manifest
    CinemaDatabaseReader_0 = pycinema.filters.CinemaDatabaseReader()
    CinemaDatabaseReader_0.inputs.path.set(args.source, False)
    CinemaDatabaseReader_0.inputs.file_column.set(args.filecolumn, False)

    # read actual images
    ImageReader_0 = pycinema.filters.ImageReader()
    ImageReader_0.inputs.table.set(CinemaDatabaseReader_0.outputs.table, False)
    ImageReader_0.inputs.file_column.set(args.filecolumn, False)
    ImageReader_0.inputs.cache.set(True, False)

    # execute pipeline
    CinemaDatabaseReader_0.update()

    # do the work
    images = ImageReader_0.outputs.images.get()
    meta = images[0].meta
    resolution = [int(meta['resolution'][0]), int(meta['resolution'][1])]
    print("image metadata")
    print("  format: hdf5")
    print("  res   : " + ", ".join(map(str, resolution)))
    print("channels: ")
    print("  number: " + str(len(images[0].channels)))
    names = []
    for channel in images[0].channels:
        names.append(channel)
    
    print("  names : " + ", ".join(names))

# set up parsers
parser = argparse.ArgumentParser(description="Cinema utility command line tool")
subparsers = parser.add_subparsers(dest='command', help='Sub-commands')

# Subparser for command 'recolor'
parser_recolor = subparsers.add_parser('recolor', help='convert Cinema float (hdf5) images to .png')
parser_recolor.add_argument('--channel', required=True, help='define channel in source images to be colormapped')
parser_recolor.add_argument('--channelrange', nargs="*", type=float, default=[-1.0,1.0], help='define channel range')
parser_recolor.add_argument('--debug', action='store_true', help='set debug mode')
parser_recolor.add_argument('--elements', nargs="*", type=str, default=[""]) 
parser_recolor.add_argument('--elementlabel', default="element", help='element label, used to find elements in database')
parser_recolor.add_argument('--colormap', default="coolwarm", help='colormap name, from matplotlib color list')
parser_recolor.add_argument('--depthchannel', default="Depth", help='define DEPTH channel name') 
parser_recolor.add_argument('--filecolumn', default="FILE", help='define FILE column name')
parser_recolor.add_argument('--nancolor', nargs="*", type=int, default=[0, 0, 0, 0]) 
parser_recolor.add_argument('--output', default="recolored.cdb", help='output cinema database')
parser_recolor.add_argument('--source', required=True, help='source cinema database')
parser_recolor.add_argument('--thumbnail', action='store_true', help='write out a thumbnail of converted image')
parser_recolor.add_argument('-v', '--verbose', action='store_true', help='enable verbose output')
parser_recolor.set_defaults(func=function_recolor)

# Subparser for command 'meta'
parser_meta = subparsers.add_parser('meta', help='dump descriptive metadata about a cinema database')
parser_meta.add_argument('--debug', action='store_true', help='set debug mode')
parser_meta.add_argument('--filecolumn', default="FILE", help='define FILE column name')
parser_meta.add_argument('-v', '--verbose', action='store_true', help='enable verbose output')
parser_meta.add_argument('source', help='source cinema database')
parser_meta.set_defaults(func=function_meta)

# parse and call subcommand arguments
args = parser.parse_args()

# Call the appropriate function based on the subcommand
if args.command:
    args.func(args)
else:
    parser.print_help()
